<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.525">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Bias in Facial Classification ML Models - 3&nbsp; Methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./results.html" rel="next">
<link href="./data.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Bias in Facial Classification ML Models</span>
    </a>
  </div>
        <div class="quarto-navbar-tools">
    <a href="https://github.com/CUBoulder-DS/5301-5000-Final-Report" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./STAT_5000_Final_Report.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./methods.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Methods</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Abstract</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./methods.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Methods</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./results.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Results</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./conclusions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Conclusions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#data-cleaning-standardizing-model-outputs" id="toc-data-cleaning-standardizing-model-outputs" class="nav-link active" data-scroll-target="#data-cleaning-standardizing-model-outputs"><span class="header-section-number">3.1</span> Data Cleaning: Standardizing Model Outputs</a>
  <ul class="collapse">
  <li><a href="#fairface-output-modifications" id="toc-fairface-output-modifications" class="nav-link" data-scroll-target="#fairface-output-modifications"><span class="header-section-number">3.1.1</span> FairFace Output Modifications</a></li>
  <li><a href="#deepface-output-modifications" id="toc-deepface-output-modifications" class="nav-link" data-scroll-target="#deepface-output-modifications"><span class="header-section-number">3.1.2</span> DeepFace Output Modifications</a></li>
  <li><a href="#source-data-modifications" id="toc-source-data-modifications" class="nav-link" data-scroll-target="#source-data-modifications"><span class="header-section-number">3.1.3</span> Source Data Modifications</a></li>
  </ul></li>
  <li><a href="#exploratory-data-analysis-eda" id="toc-exploratory-data-analysis-eda" class="nav-link" data-scroll-target="#exploratory-data-analysis-eda"><span class="header-section-number">3.2</span> Exploratory Data Analysis (EDA)</a></li>
  <li><a href="#research-questions" id="toc-research-questions" class="nav-link" data-scroll-target="#research-questions"><span class="header-section-number">3.3</span> Research Questions</a></li>
  <li><a href="#hypothesis-testing" id="toc-hypothesis-testing" class="nav-link" data-scroll-target="#hypothesis-testing"><span class="header-section-number">3.4</span> Hypothesis Testing</a>
  <ul class="collapse">
  <li><a href="#demographics" id="toc-demographics" class="nav-link" data-scroll-target="#demographics"><span class="header-section-number">3.4.1</span> Demographics</a></li>
  <li><a href="#demographics-subgroups" id="toc-demographics-subgroups" class="nav-link" data-scroll-target="#demographics-subgroups"><span class="header-section-number">3.4.2</span> Demographics’ Subgroups</a></li>
  <li><a href="#the-general-proportion-tests" id="toc-the-general-proportion-tests" class="nav-link" data-scroll-target="#the-general-proportion-tests"><span class="header-section-number">3.4.3</span> The General Proportion Tests</a></li>
  <li><a href="#notation" id="toc-notation" class="nav-link" data-scroll-target="#notation"><span class="header-section-number">3.4.4</span> Notation</a></li>
  <li><a href="#proportion-testing-of-subsets" id="toc-proportion-testing-of-subsets" class="nav-link" data-scroll-target="#proportion-testing-of-subsets"><span class="header-section-number">3.4.5</span> Proportion Testing of Subsets</a></li>
  </ul></li>
  <li><a href="#performance-measurement" id="toc-performance-measurement" class="nav-link" data-scroll-target="#performance-measurement"><span class="header-section-number">3.5</span> Performance Measurement</a>
  <ul class="collapse">
  <li><a href="#accuracy" id="toc-accuracy" class="nav-link" data-scroll-target="#accuracy"><span class="header-section-number">3.5.1</span> Accuracy</a></li>
  <li><a href="#precision" id="toc-precision" class="nav-link" data-scroll-target="#precision"><span class="header-section-number">3.5.2</span> Precision</a></li>
  <li><a href="#recall" id="toc-recall" class="nav-link" data-scroll-target="#recall"><span class="header-section-number">3.5.3</span> Recall</a></li>
  <li><a href="#f1-score" id="toc-f1-score" class="nav-link" data-scroll-target="#f1-score"><span class="header-section-number">3.5.4</span> F1-Score</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-methods" class="quarto-section-identifier"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Methods</span></span></h1>
</div>



<div class="quarto-title-meta column-body">

    
  
    
  </div>
  


</header>


<p>As described in the previous section, the two selected models (DeepFace and FairFace) are run on the UTK face dataset in order to generate output of classification across 3 categories (age, race, and gender). We evaluate the performance of this classification, and perform hypothesis testing in order to answer the key research questions.</p>
<section id="data-cleaning-standardizing-model-outputs" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="data-cleaning-standardizing-model-outputs"><span class="header-section-number">3.1</span> Data Cleaning: Standardizing Model Outputs</h2>
<p>As can be seen in <a href="data.html" class="quarto-xref"><span>Chapter&nbsp;2</span></a>, there are some key differences between the outputs of both models as well as the source data that we needed to resolve to enable comparison of each dataset to one another. We’ll focus on the primary features of age, gender, and race from each dataset.</p>
<section id="fairface-output-modifications" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="fairface-output-modifications"><span class="header-section-number">3.1.1</span> FairFace Output Modifications</h3>
<p>We’ll discuss FairFace first, as it introduces a requirement for modification to both our input information as well as the outputs for DeepFace.</p>
<ul>
<li><p><strong>Age</strong>: FairFace only provides a categorical predicted age range as opposed to a specific numeric age. We retain this age format and modify the last category of “70+” to “70-130” to ensure we can capture the gamut of all input and output ages in all datasets.</p></li>
<li><p><strong>Gender</strong>: No changes to predicted values; use “Male” and “Female”</p></li>
<li><p><strong>Race</strong>: the source data from UTKFace has 5 categories “White” “Black” “Asian” “Indian” and “Other”. Using the definitions from UTKFace, we collapse the output categories of FairFace’s Fair7 model as follows:</p></li>
</ul>
<p>[“Southeast Asian”,“East Asian”] =&gt; “Asian” [“Middle Eastern” , “Latino_Hispanic] =&gt;”Other”</p>
</section>
<section id="deepface-output-modifications" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="deepface-output-modifications"><span class="header-section-number">3.1.2</span> DeepFace Output Modifications</h3>
<ul>
<li><p><strong>Age</strong>: Cut the predicted age into bins based upon the same prediction ranges provided by FairFace. If the DeepFace predicted age falls into a range provided by FairFace, provide that as the predicted age range for DeepFace.</p></li>
<li><p><strong>Gender</strong>: we adjust the DeepFace gender prediction outputs to match that of the source and FairFace data with the following refactoring: “Man” =&gt; “Male” “Woman” =&gt; “Female”</p></li>
<li><p><strong>Race</strong>: we adjust the DeepFace race prediction outputs to match that of the source dataset with the following refactoring:</p></li>
<li><p>“white” =&gt; “White”</p></li>
<li><p>“black” =&gt; “Black”</p></li>
<li><p>“indian” =&gt; “Indian”</p></li>
<li><p>“asian” =&gt; “Asian”</p></li>
<li><p>[“middle eastern”, “latino hispanic”] =&gt; “Other”</p></li>
</ul>
</section>
<section id="source-data-modifications" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="source-data-modifications"><span class="header-section-number">3.1.3</span> Source Data Modifications</h3>
<ul>
<li><p><strong>Age:</strong> We cut the predicted age into bins based upon the same prediction ranges provided by FairFace. If the input / source data age falls into a range provided by FairFace, provide that is the source age range for the image subject.</p></li>
<li><p><strong>Gender:</strong> No changes.</p></li>
<li><p><strong>Race:</strong> No changes.</p></li>
</ul>
</section>
</section>
<section id="exploratory-data-analysis-eda" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="exploratory-data-analysis-eda"><span class="header-section-number">3.2</span> Exploratory Data Analysis (EDA)</h2>
<!-- PC 
I don't know that the below language reflects the plots done in section 2. Are we talking about section 2, or section 4 (results)

Should we change "also perform" to "we plan to perform?" by this point in the paper, we haven't done those calculations yet.

May need some insight here before making changes.
-->
<p>Our EDA performed on the source UTK dataset can be seen in the previous section in Figure 2.2. The EDA performed on the output from the models can be summarized as follows, and is presented in the Results section:</p>
<ul>
<li>Visualization of the histograms of distributions of predictions, per each category, per each model</li>
</ul>
<p>We also perform some meta-analysis on the statistics and performance metrics calculated from the model outputs:</p>
<ul>
<li>Visualization of the p-values vs F1-score across all hypothesis tests across both models</li>
<li>Confusion matrix of whether we reject or fail to reject the null hypothesis based on power and F1 score</li>
</ul>
</section>
<section id="research-questions" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="research-questions"><span class="header-section-number">3.3</span> Research Questions</h2>
<p>We evaluate the output of the 2 models in order to answer the following questions:</p>
<!--PC
Below - some of these research questions can't be answered with hypothesis testing.  Commented those out and changed to new questions.
-->
<ul>
<li><p>Is it possible to identify, detect, and classify biases in machine learning models using proportionality testing?</p></li>
<li><p>Is bias prevalent in facial recognition machine learning models? <!---   Can one model be shown to have statistically significant less bias than the other?
-   Does one model outperform the other in a statistically significant manner, in all aspects?
-   Does one model outperform the other in a statistically significant manner, in certain aspects? --></p></li>
<li><p>Can one model be shown to have a greater quantity of statistically significant biases than the other?</p>
<ul>
<li><p>in all aspects?</p></li>
<li><p>In specific/certain aspects?</p></li>
</ul></li>
<li><p>Are there disparate outcomes (i.e.&nbsp;higher chance of incorrect predictions) for one racial group vs.&nbsp;another?</p></li>
</ul>
</section>
<section id="hypothesis-testing" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="hypothesis-testing"><span class="header-section-number">3.4</span> Hypothesis Testing</h2>
<p>Our data consists of three main sets: the source input data, the Fairface output data, and the Deepface output data.</p>
<p>We’ll be creating our hypothesis tests by running as two-sample proportion tests. The population is the set of all labels (of race, age, and gender as defined below) for a given image, for all face images. The first sample will be the source dataset “correct” labels of the images, and the 2nd sample will be the output of a given model between FairFace and DeepFace, respectively. The base null hypothesis will produce no difference in sample proportions. Gaining a statistically significant result would allow us to reject our <em>null hypothesis</em> in favor of the <em>alternative hypothesis</em>. In other words, rejecting the original assumption means there is a statistically large enough difference between the source data and output data, and could indicate that the source and predicted information originate from differing populations, which is a potential indicator of bias for or against the protected classes in question<!--a bias in a model-->. We use a significance level of 99.7% to mitigate the risk of rejecting the the null hypothesis when it is true. <!--accurately judge the strength of the test statistic.--></p>
<p>We’ll be testing across different subsets contained within the data, as listed below:</p>
<section id="demographics" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="demographics"><span class="header-section-number">3.4.1</span> Demographics</h3>
<ul>
<li>Age Group</li>
<li>Gender</li>
<li>Race</li>
</ul>
</section>
<section id="demographics-subgroups" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="demographics-subgroups"><span class="header-section-number">3.4.2</span> Demographics’ Subgroups</h3>
<ul>
<li>Age Group (9 groups)
<ul>
<li>0-2</li>
<li>3-9</li>
<li>10-19</li>
<li>20-29</li>
<li>30-39</li>
<li>40-49</li>
<li>50-59</li>
<li>60-69</li>
<li>70-130</li>
</ul></li>
<li>Gender (2 groups)
<ul>
<li>Female</li>
<li>Male</li>
</ul></li>
<li>Race (5 groups)
<ul>
<li>Asian</li>
<li>Black</li>
<li>Indian</li>
<li>Other</li>
<li>White</li>
</ul></li>
</ul>
</section>
<section id="the-general-proportion-tests" class="level3" data-number="3.4.3">
<h3 data-number="3.4.3" class="anchored" data-anchor-id="the-general-proportion-tests"><span class="header-section-number">3.4.3</span> The General Proportion Tests</h3>
<p>Our hypothesis tests will be testing different proportions within these subgroups between the source data and the output data.</p>
<p>The general format of our hypothesis tests will be:</p>
<p><span class="math inline">\(H_0: p_1 = p_2\)</span></p>
<p><span class="math inline">\(H_A: p_1 \neq p_2\)</span></p>
<p>With the following test statistic:</p>
<p><span class="math display">\[
\dfrac{(\hat p_1 - \hat p_2)}{\sqrt{ \hat p (1 - \hat p)  (\dfrac{1}{n_{p_1}} + \dfrac{1}{n_{p_2}}})}
\]</span></p>
<p>With the p-value being calculated by:</p>
<p><span class="math inline">\(P(|Z| &gt; z | H_0)\)</span></p>
<p><span class="math inline">\(= P(|Z| &gt; \dfrac{(\hat p_1 - \hat p_2)}{\sqrt{ \hat p (1 - \hat p) (\dfrac{1}{n_{p_1}} + \dfrac{1}{n_{p_2}}})}\)</span>,</p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(p_1\)</span> = the source dataset categories labels given and <span class="math inline">\(p_2\)</span> = the chosen model’s labels given.</li>
<li><span class="math inline">\(\hat p\)</span> = the pooled proportion.</li>
<li><span class="math inline">\(n_{p_1}, n_{p_2}\)</span> = the size of each sample.</li>
</ul>
<!-- PC -->
<p>We also calculate the power of each test performed, and use a power level threshold of 0.8 in order to assess the strength of the p-value calculated.</p>
<p>We believe that using two-sample proportion testing is an appropriate means by which we can evaluate the outputs of the two facial recognition models in comparison to the source data. In leveraging two-sample proportion tests, we can infer whether or not the proportions of age, gender, or race (or some combination thereof) from the UTKFace dataset (i.e.&nbsp;1st sample) originate from the same population as the outputs from each facial recognition model (i.e.&nbsp;2nd dataset).</p>
<p>In theory, similar proportions of protected classes between the two datasets could suggest that the source data and predicted data originate from the same population (pictures of people), and would thus indicate an absence of bias against the protected class in question. Vastly different proportions, however, could indicate that the source data and predicted data are from differing populations and indicate a bias against the protected classes in question.</p>
<p>Leveraging p-values and powers calculated on our samples for our protected classes of age, gender, and race, should enable us to provide a clear picture of any biases that may manifest from one or both models. Leveraging F1 scores (as described below) will help us identify the specific cases of bias, and whether it is in favor of or against a specific group.<!--in cases of inconclusive results from p-value and power should assist us in identifying potential error.--></p>
<!-- end PC-->
</section>
<section id="notation" class="level3" data-number="3.4.4">
<h3 data-number="3.4.4" class="anchored" data-anchor-id="notation"><span class="header-section-number">3.4.4</span> Notation</h3>
<p>We introduce notation for the specific tests we perform:</p>
<p>Let <span class="math inline">\(R\)</span> be race, then <span class="math inline">\(R \in \{Asian, Black, Indian, Other, White\} = \{A, B, I, O, W\}\)</span></p>
<p>Let <span class="math inline">\(G\)</span> be gender, then <span class="math inline">\(G \in \{Female, Male\} = \{F, M\}\)</span></p>
<p>Let <span class="math inline">\(A\)</span> be age, then <span class="math inline">\(A \in \{[0,2], [3,9], [10,19], [20,29], [30,39], [40,49], [50,59], [60,69], [70,130]\};\)</span> or <span class="math inline">\(A = \{1, 2, 3, 4, 5, 6, 7, 8, 9\}\)</span></p>
<p>Let <span class="math inline">\(D\)</span> be the dataset, then <span class="math inline">\(D \in \{Source, Fairface, Deepface\} = \{D_0, D_f, D_d\}\)</span></p>
</section>
<section id="proportion-testing-of-subsets" class="level3" data-number="3.4.5">
<h3 data-number="3.4.5" class="anchored" data-anchor-id="proportion-testing-of-subsets"><span class="header-section-number">3.4.5</span> Proportion Testing of Subsets</h3>
<p>Using this notation, we can simplify our nomenclature for testing a certain proportion of an overall demographic.</p>
<p>For example, we can test if the proportion of <em>Female</em> in the Fairface output is statistically different than the proportion of <em>Female</em> from the source.</p>
<p>Hypothesis Test:</p>
<p><span class="math inline">\(H_0: p_{F, D_f} = p_{F,D_0}\)</span></p>
<p><span class="math inline">\(H_A: p_{F, D_f} \neq p_{F,D_0}\)</span></p>
<p>P-value Calculation:</p>
<p><span class="math inline">\(P(|Z| &gt; \dfrac{(\hat p_1 - \hat p_2)}{\sqrt{ \hat p (1 - \hat p) (\dfrac{1}{n_{p_1}} + \dfrac{1}{n_{p_2}}})})\)</span>,</p>
<p>where</p>
<ul>
<li><span class="math inline">\(\hat p_1 = p_{F, D_0}\)</span>: proportion of females from the source data</li>
<li><span class="math inline">\(\hat{p_2} = p_{F, D_f}\)</span>: proportion of females from the FairFace output</li>
</ul>
<p>Additionally, we could test for different combinations of subsets within demographics. For instance, if we wanted to test for a statistically significant difference between the proportion of those who <em>Female</em>, given that they were <em>Black</em>, as predicted by DeepFace, then we could write a hypothesis test like:</p>
<p><span class="math inline">\(H_0: p_{D_d, F|B} = p_{D_0, F|B}\)</span></p>
<p><span class="math inline">\(H_A: p_{D_d, F|B} \neq p_{D_0, F|B}\)</span></p>
<p>These were two specific hypothesis tests, however, we’ll be testing all combinations of these parameters and reporting back on any significant findings.</p>
<!--PC-->
<p>In the above, we’ve outlined our methods for examining a total of 432 hypothesis tests per recognition model on the totality of, and smaller samples of, our overall dataset. We have elected to sub-divide our source and predicted samples by these protected classes to inspect and investigate whether or not there may be bias against groupings of protected classes.</p>
<p>For instance, in the performance of our hypothesis tests, we may find an absence of bias when only examining proportions of gender between samples. However, by examining a subset of our samples, such as subject gender given the subject’s membership in a specific racial category, we may find biases in predictions of subject gender given their membership in a specific racial group.</p>
<p>This could help us answer questions and draw conclusions about such groups. For example:</p>
<!--"Model X demonstrates bias in favor of correctly predicting race, given the subject is young." - which also suggests a bias against correctly predicting the race of older subjects in a model. Such a bias, if used in a decision making process, could result in age discrimination.

"Model Y demonstrates bias against predicting correct gender, given the subject image is Black, Asian, or Other." - which also suggests a bias for correctly predicting gender, given the subject is White or Indian. Such a bias, if used in a decision making process, could result in racial discrimination.
-->
<p>“Model X demonstrates bias in predicting the race of older subjects.” Such a statement is not one of bias for or against the target group, but that a bias exists. A bias in either direction, if used in a decision-making process, could result in age discrimination.</p>
<p>“Model Y demonstrates bias in predicting gender, given the subject is Black, Asian, or Other.” Such a statement is not one of bias for or against the target groups, but a statement that a bias exists. Such a bias, if used in a decision-making process, could result in gender or racial discrimination.</p>
<p>Structuring our tests in this manner will enable us to quickly analyze and report on the results of our tests.</p>
<!--end PC-->
</section>
</section>
<section id="performance-measurement" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="performance-measurement"><span class="header-section-number">3.5</span> Performance Measurement</h2>
<p>We evaluate the performance of the models in order to choose which models to use (as described in the Data section), to ensure data integrity, and to evaluate the hypothesis testing in context of performance. These measures are not used in the calculation of the statistical/hypothesis testing.</p>
<!-- ::: callout-note -->
<!-- This performance section is important in choosing the correct models to ensure data integrity, however for the actual statistical tests, we'll focused on more common statistics like mean and proportion. -->
<!-- PC -->
<!-- NOTE: From Rubric - May need to relocate sub-sections from data back to here: -->
<!-- -   Exploratory data analysis -->
<!-- -   what modifications were necessary to make the dataset ready for analysis? -->
<!-- Separate of those two - may need explanations on the analyses we performed and **why we think they are appropriate.** We have part of that regarding the F1 use to possibly identify errors, may need more on two-prop tests and the like -->
<!-- end PC-->
<!-- PC -->
<!-- These are PC's recommendations on how we can look at the additional values: -->
<!-- For cases in which we reject the statistical null hypothesis, we plan to evaluate the below metrics for the same output category. Should we reject a null hypothesis for, let's say, the proportion of females, given that they are asian, we will examine the accuracy and F-1 scores for the same category. We will consider the following range of values: -->
<!-- -   F1 Score \< .9 vs F1 Score \>= 0.9 -->
<!-- -   Power \< .8 vs Power \>= .8 -->
<!-- -   p-value \< .003 vs pvalue \>= .003 -->
<!-- PC -->
<!-- ::: -->
<p>There are four main measures of performance when evaluating a model:</p>
<ul>
<li><strong>Accuracy</strong></li>
<li><strong>Precision</strong></li>
<li><strong>Recall</strong></li>
<li><strong>F1-Score</strong></li>
</ul>
<p>Each of these performance measures has their own place in evaluating models; in order to explain the differences between these metrics, we start with concepts of positive and negative outcomes.</p>
<div class="columns">
<div class="column" style="width:70%;">
<ul>
<li><strong>True Positive:</strong> predicted positive, was actually positive (correct)</li>
<li><strong>False Positive:</strong> predicted positive, was actually negative (incorrect)</li>
<li><strong>True Negative:</strong> predicted negative, was actually negative (correct)</li>
<li><strong>False Negative:</strong> predicted negative, was actually positive (incorrect)</li>
</ul>
<p>These outcomes can be visualized in a confusion matrix. In <a href="#fig-confusion" class="quarto-xref">Figure&nbsp;<span>3.1</span></a>, green are correct predictions while red are incorrect predictions.</p>
</div><div class="column" style="width:30%;">
<div id="fig-confusion" class="quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-confusion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/confusion_matrix.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-confusion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.1: Confusion_matrix
</figcaption>
</figure>
</div>
</div>
</div>
<section id="accuracy" class="level3" data-number="3.5.1">
<h3 data-number="3.5.1" class="anchored" data-anchor-id="accuracy"><span class="header-section-number">3.5.1</span> Accuracy</h3>
<p><strong>Accuracy</strong> is the ratio of correct predictions to all predictions. In other words, the total of the green squares divided by the entire matrix. This is arguably the most common concept of measuring performance. It ranges from 0-1 with 1 being the best performance.</p>
<p><span class="math inline">\(Acccuracy = \frac{TP+TN}{TP + TN + FP + FN}\)</span></p>
</section>
<section id="precision" class="level3" data-number="3.5.2">
<h3 data-number="3.5.2" class="anchored" data-anchor-id="precision"><span class="header-section-number">3.5.2</span> Precision</h3>
<p><strong>Precision</strong> is the ratio of true positives to the total number of positives (true positive + true negative).</p>
</section>
<section id="recall" class="level3" data-number="3.5.3">
<h3 data-number="3.5.3" class="anchored" data-anchor-id="recall"><span class="header-section-number">3.5.3</span> Recall</h3>
<p><strong>Recall</strong> is the ratio of true positives to the number of total correct predictions (true positive + false negative).</p>
</section>
<section id="f1-score" class="level3" data-number="3.5.4">
<h3 data-number="3.5.4" class="anchored" data-anchor-id="f1-score"><span class="header-section-number">3.5.4</span> F1-Score</h3>
<p><strong>F1-Score</strong>* is known as the harmonic mean between precision and recall. <strong>Precision</strong> and <strong>Recall</strong> are useful in their own rights, but the F1-Score is useful in the fact it’s a balanced combination of both precision and recall. It ranges from 0-1 with 1 being the best performance.</p>
<p>F1-Score <span class="math inline">\(= \frac{2 * Precision * Recall}{Precision + Recall}\)</span></p>
<p>When considering the classification of a subject by protected classes of age, gender, and race, we believe that stronger penalties should be assigned in making an improper classification decision. Due to F1 being the harmonic mean of precision and recall, incorrect classification will more directly impact the score of each model in its prediction of protected classes, and do so more strongly than an accuracy calculation <span class="citation" data-cites="mediumPerf">(<a href="references.html#ref-mediumPerf" role="doc-biblioref">Huilgol 2021</a>)</span>.</p>
<p>We calculate F1 score as a measure of performance of our selected machine learning models. This was not used in the calculation or results of the hypothesis tests, but will be used for when we draw conclusions of our tests based upon p-value and statistical power. Namely, we do not plan to control for statistical power / Type-II error when running our 432 hypothesis tests, so statistical power may vary from test to test. Using F1 and Accuracy scores can support us in identifying specific cases of bias (and whether it is for or against) one or more protected classes. We elect to use an F1 score threshold of 0.9 to make this determination.<!--Using F1 scores to assess p-values in cases of low statistical power should assist us in identifying potential Type-II Errors. We set a F1 score threshold of 0.9 to make this determination.--></p>
<!-- ::: callout-note -->
<!-- ## From the report requirements -->
<!-- Also can be called "Analyses" -->
<!-- This section might contain several subsections as needed. -->
<!-- -   At least one subsection should describe the exploratory data analysis you did. -->
<!-- -   What modifications were necessary to make the dataset ready for analysis? (e.g. dealing with missing values, removing certain rows, replacing/cleaning text values, binning, etc) -->
<!-- -   Describe the analyses you did to answer the question of interest. **Explain why you believe these methods are appropriate.** -->
<!-- Some methods we learn in this class include distribution comparison, correlation analysis, and hypothesis testing. You are required to include hypothesis tests into the project, but feel free to use additional methods to tell a good story about the data. -->
<!-- ::: -->


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-joyGender" class="csl-entry" role="listitem">
Buolamwini, Joy. 2023. <span>“<span class="nocase">Gender Shades: Intersectional Accuracy Disparities in</span>.”</span> <em>MIT Media Lab</em>. <a href="https://www.media.mit.edu/publications/gender-shades-intersectional-accuracy-disparities-in-commercial-gender-classification">https://www.media.mit.edu/publications/gender-shades-intersectional-accuracy-disparities-in-commercial-gender-classification</a>.
</div>
<div id="ref-perplineup" class="csl-entry" role="listitem">
Georgetown Law. 2016. <span>“<span class="nocase">The Perpetual Line-Up: Unregulated Police Face Recognition in America</span>.”</span> <em><span>Center on Privacy <span>&amp;</span> Technology</span></em>. <a href="https://www.perpetuallineup.org">https://www.perpetuallineup.org</a>.
</div>
<div id="ref-mediumPerf" class="csl-entry" role="listitem">
Huilgol, Purva. 2021. <span>“<span class="nocase">Accuracy vs. F1-Score - Analytics Vidhya - Medium</span>.”</span> <em>Medium</em>, December. <a href="https://medium.com/analytics-vidhya/accuracy-vs-f1-score-6258237beca2">https://medium.com/analytics-vidhya/accuracy-vs-f1-score-6258237beca2</a>.
</div>
<div id="ref-fairface" class="csl-entry" role="listitem">
Karkkainen, Kimmo, and Jungseock Joo. 2021. <span>“FairFace: Face Attribute Dataset for Balanced Race, Gender, and Age for Bias Measurement and Mitigation.”</span> In <em>Proceedings of the IEEE/CVF Winter Conference on Applications of Computer Vision</em>, 1548–58.
</div>
<div id="ref-nytimes" class="csl-entry" role="listitem">
Lohr, Steve. 2018. <span>“<span class="nocase">Facial Recognition Is Accurate, if You<span>’</span>re a White Guy</span>.”</span> <em>N.Y. Times</em>, February. <a href="https://www.nytimes.com/2018/02/09/technology/facial-recognition-race-artificial-intelligence.html">https://www.nytimes.com/2018/02/09/technology/facial-recognition-race-artificial-intelligence.html</a>.
</div>
<div id="ref-nist" class="csl-entry" role="listitem">
NIST. 2020. <span>“<span class="nocase">NIST Study Evaluates Effects of Race, Age, Sex on Face Recognition Software <span><span class="math inline">\(\vert\)</span></span> NIST</span>.”</span> <em>NIST</em>. <a href="https://www.nist.gov/news-events/news/2019/12/nist-study-evaluates-effects-race-age-sex-face-recognition-software">https://www.nist.gov/news-events/news/2019/12/nist-study-evaluates-effects-race-age-sex-face-recognition-software</a>.
</div>
<div id="ref-deepface" class="csl-entry" role="listitem">
Serengil, Sefik Ilkin, and Alper Ozpinar. 2021. <span>“HyperExtended LightFace: A Facial Attribute Analysis Framework.”</span> In <em>2021 International Conference on Engineering and Emerging Technologies (ICEET)</em>, 1–4. IEEE. <a href="https://doi.org/10.1109/ICEET53442.2021.9659697">https://doi.org/10.1109/ICEET53442.2021.9659697</a>.
</div>
<div id="ref-utkdataset" class="csl-entry" role="listitem">
<span>“<span>UTKFace</span>.”</span> 2021. <em>UTKFace</em>. <a href="https://susanqq.github.io/UTKFace">https://susanqq.github.io/UTKFace</a>.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation column-body">
  <div class="nav-page nav-page-previous">
      <a href="./data.html" class="pagination-link  aria-label=" &lt;span="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Data</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./results.html" class="pagination-link" aria-label="<span class='chapter-number'>4</span>&nbsp; <span class='chapter-title'>Results</span>">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Results</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>